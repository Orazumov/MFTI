# Двумерные массивы. Динамическое программирование.

# путь есть шахматная доска M на N.

# У нас есть король. Он стоит в ячейке 1/1.
# Нужно узнать сколькими способами король может добраться до
# клетки M/N если он может шагать только вправо и вниз.

# Мы ищем количество траекторий для клетки: Кnm (N строка, M - элемент в строке)/

# Ki,j = Ki-1,j + Ki,j-1 - целевая рекурентаная фунция

# если расписать все варианты, получаем треугольник Паскаля, положенный на 45 градусов.
# см. лекцию, там хорошо разрисовано.

# Наибольшая общая последовательность.

# A, B - одномерные массивы чисел. len(A) == N, len(B) == M.

# Подпоследовательность А - список С, содержащий элементы A в исх. порядке, но возм. не все.

# [] - подпоследовательность любой последовательности А

# F - дляна общей подпоследовательности.

# Fij - длина наибольшей возможной подпоследовательности частей А и B:
# A[0:i] - часть А, сод. первые i элементов.
# B[0:j] - часть B, сод. первые j элементов.
#      | 1 + Fi-1,j-1 если ai = bj
#Fij =<
#      | max(Fi,j-1 , Fi-1,j) если ai != bj

#Foj = 0 ; Fio = 0 (общая подпоследовательность - пустая!)

def lcs(A,B):
    F = [[0]*(len(B)+1) for i in range(len(A)+1)] # зарезервировали место для массива с помощью генератора.
    for i in range(1, len(A) + 1):
        for j in range(1, len(B) + 1):
            if A[i-1] == B[j-1]:
                F[i][j] = 1 + F[i-1][j-1]
            else:
                F[i][j] = max(F[i-1][j], F[i][j-1])
    return F[-1][-1] # возвращаем последний элемент, это длина наибольшей общей последовательности.

# Наибольшая возрастающая подпоследовательность.
# Вычисляем ее длину.

# Fi - наибольшая возр. подпоследовательность для части А[0:i], которая
# заканчивается и содержит элемент ai = A[i-1]

# Fi = max(Fj) + 1
# при этом j < i & ai > aj

# крайний случай: Fo = 0

def gis(A):
    F = [0]*(len(A) + 1)
    for i in range(1, len(A) + 1):
        m = 0
        for j in range(0, i):
            if A[i] > A[j] and F[j] > m:
                m = F[j]
# по итогам m либо = 0, либо максимально возможный элемент последов. найден!
        F[i] = m + 1
    return F[len(A)]

# Алгоритм укладки рюкзака.
# Есть рюкзак, набор вещей и максимальная масса рюкзака M.
# У каждого предмета есть стоимость S и массам m.
# какую максимальную стоимость предметов можно унести?
# лучшее решение - перебор всех подмножеств.

# но если массы дискретные, то можно решить методом динам. программирования.

from itertools import permutations
goods = (("p1", 4), ("p2", 3), ("p3", 3), ("p4", 2))
max_capacity = 6
max_degree = max_capacity / min([x[1] for x in goods])
result = []
for degree in range(1, int(max_degree) + 1):
    for ss in permutations(goods * degree, degree):
        if ss not in result and sum(map(lambda y: y[1], list(ss))) == 6:
            result.append(ss)
for i in result:
    print(" + ".join(map(lambda z: z[0], list(i))))







