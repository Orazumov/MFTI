# Лекция 12.

# Алгоритм Ливенштейна.
# редакционное расстояние между строками.
# пусть есть строка А и строка Б
A = 'колокол' # (всего N)
B = 'молоко' # (всего M)
# сколько минимально опечаток нужно сделать в первом, чтобы получлось второе?
# ошибки: 1. перепутали символ.
# 2. вставили лишний символ.
# 3. потеряли символ.

# у нас - первую букву меняем, а последнюю теряем.

# Введем функцию Fij - это мин. редакционное расстояне между срезами строк.
# A[:i] и B[:j]
# Ответ Fnm
# Рекурентная функция:

#             | Fi-1, j-1 если Ai == Bj уменьшаем на 1 символ
# Если Fij = <
#             | 1 + min(Fi-1,j, Fi,j-1, Fi-1,j-1)
#             | крайний случай: F0j = j, Fio = i, F00 = 0
#

def levenstein(A, B):
    # зарезервировали место нулями и сразу указали крайние
    # случаи: если i или j == 0
    F = [[(i + j) if (i == 0 or j == 0) else 0 for j in range(len(B) + 1)] for i in range(len(A) + 1)]
    # !!!!!!!! вложенный цикл при генераторе
    for i in range(1, len(A) + 1):
        for j in range(1, len(B) + 1):
            if A[i-1] == B[j-1]:
                F[i][j] = F[i-1][j-1]
            else:
                F[i][j] = 1 + min(F[i-1][j], F[i][j-1], F[i-1][j-1])
    return F[len(A)][len(B)]

print(levenstein('milk', 'silk'))

# Проверка равенства строк.

# Можно натравить Ливенштейна - если 0, то равны.
# А как по другому?

A = 'строки'
B = 'равны'

# если разные длины - сразу не равны!

def equal(A, B):
    if len(A) != len(B):
        return False
    for i in range(len(A)):
        if A[i] != B[i]:
            return False
    return True

# можно просто написать А == B - Питон сам сравнит две строки посимвольно

# наивный алгоритм получился лучше, чем Ливенштейн, он работает быстрее.

# а если искать подстроку в строке?
# наивный поиск:

def search_substring(s, sub):
    for i in range(0, len(s) - len(sub)):
        if equal(s[i:i+len(sub)], sub):   # ссылка на пред. ф.
            print(i)

# чтобы уменьшить асимптотику, строку можно предобработать:

# Префикс функция П строки.

# собственный суффикс - суффикс (окончание) не равный строке.

# Пs ф. - это длина максимального собственного суффикса, который является преффиксом

# Пsi - преф. ф. среза строки s[:i]

def kmp(s,t):
    index = -1
    f = prefix(s)
    k = 0
    for i in range(len(t)):
        while k > 0 and s[k] != t[i]:
            k = f[k-1]
        if s[k] == t[i]:
            k = k + 1
        if k == len(s):
            index = i - len(s) + 1
            break
    return index




