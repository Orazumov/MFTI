# реализация бинарного поиска в массиве.
# массив уже отсортирован!

# считаем что массив отсортирован по возрастанию.

def left_bound(A, key): # ищем именно левую границу.
    left = -1
    right = len(A)
    while right - left > 1:
        middle = (left + right) // 2
        if A[middle] < key:
            left = middle
        else: right = middle # даже если мы попадем, но ищем мы левую границу, правая тут нас не интересует.
        # вроде бы для нас важно правая сторона, но что если числа вообще нет? нам важно именно задать границы
        # найденных чисел.
    return left

def right_bound(A, key): # ищем именно правую границу.
    left = -1
    right = len(A)
    while right - left > 1:
        middle = (left + right) // 2
        if A[middle] <= key:
            left = middle
        else: right = middle

    return right

# затем можно задать функцию, которая будет выдавать результат поиска.

# Динамическое программирование.

# числа Фибаначчи.

def fib(n):
    if n <= 1:
        return n
    else:
        return fib(n-1) + fib(n-2)

# получается структура вызовов рекурсии, которая называется фибаначиево дерево.
# поэтому время выполнения О(Fibn) - а это экспонента! очень быстро растет время.
# на листочке сделать быстрее, при подсчете Fib(60).

# можно посчитать по другому:

fib = [0 , 1] + [0]*(n-1) # зарезервировали память нулями.
for i in range(2, n + 1):
    fib[i] = fib[i - 1] + fib[i - 2]  # динамическое программирование - рекурсия наоборот!
# нас интересует fib[n] именно он - ответ!

# исполнитель кузнечик.
# в начала сидит в клеточке 1, может прыгать только вперед.
# прыгает либо + 1
# либо + 2
# сколько различных траекторий допрыгать из 1 в N?

# в клеточку N можно попасть из N-1 или из N-2.
# Кn = Kn-2 (количество траекторий первого типа) + Kn-1 (количество траекторий второго типа)
# рекурентная функция.
# добавили на шкалу число 0 - в него 0 способов попасть, в 1 - 1 способ и т.д. получается как числа Фибоначчи.

def traj_num(N):
    K = [0, 1] + [0]*N
    for i in range(2, N+1):
        K[i] = K[i-2] + K[i-1]
    return K[N]
# запретим некоторые клетки для посещения. 4 и 7.
# пусть возможно прыгать +1, +2, +3.
# передадим в ф. массив bool, где true - можно посещать, false - нельзя.

def count_trajectories(N, allowed:list):
    K = [0, 1, int(allowed[2])] + [0] * (N-3)
    for i in range(3, N+1):
        if allowed[i]:
            K[i] = K[i-1] + K[i-2] + K[i-3]
    return K[N]

# Минимальная стоимость достижения клетки N.

# price[i] цена за посещение клетки i
# C[i] - минимально возможная стоимость достижения клетки i
# пусть кузнечику доступны шаги +1 и +2
# Ci = pricei + min(Ci-1, Ci-2)
# C1 = price1
# C2 = price1 + price2
# считаем что ноль недостижим!
# float("-inf") минус бесконечность

def count_in_cost(N, price:list):

    C = [float("-inf"), price[1], price[1] + price[2]] + [0] * (N-2) # посчитали для первых трех элементов, добавили нули до N-2, т.к. первый посчитали уже.
    for i in range(3, N+1):
        C[i] = price[i] + min(C[i-1], C[i-2])

    return C[N] # минимальная стоимость.
    # чтобы понять по какой именно траектории придти, нужен массив и в него записывать пункты, которые мы проходили при минимальном пробеге.

# Двумерные массивы.

# линеаризация двум. массива.

# вместо Aij ---> A[i*M + j] - линеаризация!
# N строк, M элементов в строке, ширина массива фиксирована.

# или создать список списков.

# A = [[0]*M]*N - это неверно! т.к. будет N ссылок на массив с M нулями.
# A = [[0*M] for i in range(N)] - правильно!
# A[0] == A[1] True
# A[0] is A[1] False это разные объекты!





